# 一些废话

这游戏已经发布一年多了，而开发者去年年中就已跑路，留下一个全是bug的游戏。我觉得很可惜，因此决定自己上手，通过反编译-重编译IL文件，看看能不能修复一些严重影响体验的恶性bug。我虽然没学过c#，也没有游戏编程经验，但所幸的是我的主要编程语言是c++，而它在语法上与c#有诸多相似之处，所以我读这游戏的代码没什么压力。目前已知该补丁成功修复了激光武器射弹消失的问题。理论上它应该适用于所有出现射弹消失问题的武器，但由于个人时间有限，未能一一测试。之后如果我有空闲，还会尝试修复更多bug，并更新在这篇指南里。

# 下载链接

请查看本github仓库的Releases页面。

# 定位过程

突然之间，我发现我的激光手枪开火后子弹直接消失了了，而其它枪械工作正常。显然，这是个bug。而由于很长一段时间没捡到弹药，我并不知道激光枪是何时开始出现问题的。我首先怀疑是我加了什么技能而导致了这个bug的触发。从游戏开始到现在，我只点了黑客、开锁、激光武器和敏捷（Grace直译优雅但我觉得敏捷更直观点）。显然黑客和开锁跟激光枪没什么关系，于是我把重点怀疑对象放在了后两者身上。

我先是找到了游戏的存档文件。修改这个游戏的存档简直毫无难度――它甚至不是用二进制存储的，而是直接用文本信息存储的。我分别单独修改了敏捷和激光技能，然后发现问题出在敏捷上。当我把敏捷从3改到2时，激光枪又能正常开火了。但我并不想因为这个bug而永远将敏捷维持到2，于是我开始反编译游戏文件，希望从代码层面上定位问题。

首先我找到了掷骰子里和敏捷相关的部分，并进行了一些修改和测试，但是问题依旧。

然后我开始从敏捷主要影响的“回合判定”问题着手，浏览游戏的回合判定部分代码。我发现在CharaterInfo类的UpdateStats函数中，有如下代码形式：

【图片】

显然，我的敏捷达到3点时会导致this.reloadTurns=1且this.recoveryTurns<=0（其中，this指的就是CharacterInfo对象，这两个是其成员变量）。reloadTurns显然影响的是装填，和开火没什么关系，于是我尝试修改了recoveryTurns，让其在满足this.recoveryTurns<=0的情况下强制为1，再次打开游戏，激光手枪又能正常开火了。

但仅仅是让激光枪能正常开火并不能满足我。毕竟从代码上看，开发者对这个能力的设置是让其最小能等于0的。况且这显然只是更深层次问题的一个浅层表现，如果仅止步于此，那么未解决的底层问题可能会引起其它的bug现象。

我复原了代码后，再次测试了我已有的其它枪械：实弹手枪和等离子手枪（此外我还捡过两把实弹步枪，但由于物品bug它们都消失了），开火均正常。同时测试了激光手枪的连发开火模式，奇异的是也能正常命中敌人，唯独单发开火不行。

对比单发和连发开火的特征，我有了进一步的猜测：出于可能是动画脚本或武器数值设置之类的未知原因，激光枪在当前回合的“开火”仅仅是播放了一个主角的开火动画，而实际开火的“行为”，由于超出了一个回合的非暂停时间，射弹并没有在此回合产生，而是在下一次暂停结束后才产生。而由于游戏中action recovery turns机制的存在，主角可能在执行开火后的一小段时间内游戏不会直接暂停，从而激光子弹能正常产生。当action recovery turn为0时，开火动作在执行后游戏立刻被暂停，而这导致一些值初始化发生错误，从而进一步导致了子弹的消失。

所以我接下来的浏览重点应该是开火和射弹产生部分。由于我并非这个游戏的开发者，手上也只有通过IL文件反编译的代码，而没有这个游戏的编译前的原始代码，这意味着我没有unity提供的内置调试工具、调试符号和代码注释等让调试流程变得更简单的东西。所幸的是，游戏在画面的右下角自带一个可以输出东西的窗口，我可以利用这个东西来输出一些内部变量的具体数值。

首先是这个游戏的回合判定器：Turn类，该类继承自unity提供的MonoBehavior类，因此它会有一个Update函数用于游戏每帧调用。我找到了该函数并随其调用链逐层向下，发现了射弹创建相关的代码及其对应的另一个继承自MoniBehavior的类：AttackLine，鉴于其为基类为MonoBehavior，它最终应该会被挂载于某个GameObject上，很可能是射弹之类的。

在主角执行攻击动作时，会在AIAction.DoAttack()中从pool里申请一个AttackLine对象，并调用AttackLine.StartTrajectory()对射弹的部分信息进行初始化。同时StartTrajectory函数在执行过程中将射弹被保存在游戏的Turn对象中，确保其在其该有的生命周期中一直存在，而AttackLine会在其存在时每帧调用它自己的Update，从而不断进行当前子弹位置的计算并进行射线检测判断子弹是否击中对象，如果击中对象后对子弹进行销毁。

我在AttackLine.Update和其调用的AttackLine.DoUpdate()中手动添加了一些“调试信息”，让其能够输出子弹的当前位置及朝向信息，以及函数的当前的执行位置。最后发现，激光枪在执行开火后，射弹确实在下一回合产生，并且此时产生的射弹初始位置坐标显然是一个错误值：(1000,0,0)，这证实了我的一部分猜想。那么接下来要搞明白的问题是，为什么子弹的初始位置没有正确地初始化？

进一步阅读DoUpdate的内容后，我发现它用了AttackLine的一个bool型成员变量：wpnSet