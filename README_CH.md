| [English](README.md) | 简体中文 |
# 一些废话

这游戏已经发布一年多了，而开发者去年年中就已跑路，留下一个全是bug的游戏。我觉得很可惜，因此决定自己上手，通过反编译-重编译IL文件，看看能不能修复一些严重影响体验的恶性bug。我虽然没学过c#，也没有游戏编程经验，但所幸的是我的主要编程语言是c++，而它在语法上与c#有诸多相似之处，所以我读这游戏的代码没什么压力。目前已知该补丁成功修复了激光武器射弹消失的问题。理论上它应该适用于所有出现射弹消失问题的武器，但由于个人时间有限，未能一一测试。之后如果我有空闲，还会尝试修复更多bug，并更新在这篇指南里。

# 下载链接

请查看[本github仓库的Releases页面](https://github.com/DexArson/Mechajammer-unofficial-patch/releases)。

# 使用方法

粘贴dll文件到`你的游戏安装文件夹\Mechajammer_Data\Managed`


如果你对游戏代码的分析以及bug的形成原理并不感兴趣，你现在就可以关掉这个页面而不必浏览接下来的部分了。

# 定位过程

突然之间，我发现我的激光手枪开火后子弹直接消失了了，而其它枪械工作正常。显然，这是个bug。而由于很长一段时间没捡到弹药，我并不知道激光枪是何时开始出现问题的。我首先怀疑是我加了什么技能而导致了这个bug的触发。从游戏开始到现在，我只点了黑客、开锁、激光武器和优雅（Grace）。显然黑客和开锁跟激光枪没什么关系，于是我把重点怀疑对象放在了后两者身上。

我先是找到了游戏的存档文件。修改这个游戏的存档简直毫无难度――它甚至不是用二进制存储的，而是直接用文本信息存储的。我分别单独修改了Grace和激光技能，然后发现问题出在Grace上。当我把Grace从3改到2时，激光枪又能正常开火了。但我并不想因为这个bug而永远将Grace维持到2，于是我开始反编译游戏文件，希望从代码层面上定位问题。

首先我找到了和游戏中掷骰子机制相关代码里和Grace相关的部分，并进行了一些修改和测试，但是问题依旧。

然后我开始从受Grace影响的另一个东西“回合判定”问题着手，浏览游戏的回合判定部分代码。我发现在`CharaterInfo`类的`UpdateStats`函数中，有如下代码：

```cs
this.reloadTurns = 3 - ((int)this.Grace + (int)this.GraceMod);
this.recoveryTurns = 3 - ((int)this.Grace + (int)this.GraceMod);
if (this.recoveryTurns < 0)
{
	this.recoveryTurns = 0;
}
```

显然，我的Grace达到3点时会导致`this.reloadTurns == 1`且`this.recoveryTurns <= 0`（其中，this指的就是CharacterInfo对象，这两个是其成员变量）。reloadTurns显然影响的是装填，和开火没什么关系，于是我尝试修改了`recoveryTurns`，让其在满足`this.recoveryTurns <= 0`的情况下强制为1，再次打开游戏，激光手枪又能正常开火了。

但仅仅是让激光枪能正常开火并不能满足我。毕竟从代码上看，开发者对这个能力的设置是让其最小能等于0的。况且这显然只是更深层次问题的一个浅层表现，如果仅止步于此，那么未解决的底层问题可能会引起其它的bug现象。

我复原了代码后，再次测试了我已有的其它枪械：实弹手枪和等离子手枪（此外我还捡过两把实弹步枪，但由于物品bug它们都消失了），开火均正常。同时测试了激光手枪的连发开火模式，奇异的是也能正常命中敌人，唯独单发开火不行。

对比单发和连发开火的特征，我有了进一步的猜测：出于可能是动画脚本或武器数值设置之类的未知原因，激光枪在当前回合的“开火”仅仅是播放了一个主角的开火动画，而实际开火的“行为”，由于超出了一个回合的非暂停时间，射弹并没有在此回合产生，而是在下一次暂停结束后才产生。而由于游戏中action recovery turns机制的存在，主角可能在执行开火后的一小段时间内游戏不会直接暂停，从而激光子弹能正常产生。当action recovery turn为0时，开火动作在执行后游戏立刻被暂停，而这导致一些值初始化发生错误，从而进一步导致了子弹的消失。

所以我接下来的浏览重点应该是开火和射弹产生部分。由于我并非这个游戏的开发者，手上也只有通过IL文件反编译的代码，而没有这个游戏的编译前的原始代码，这意味着我没有unity提供的内置调试工具、调试符号和代码注释等让调试流程变得更简单的东西。所幸的是，游戏在画面的右下角自带一个可以输出东西的窗口，我可以利用这个东西来输出一些内部变量的具体数值。

首先是这个游戏的回合判定器：`Turns`类：

```cs
public class Turns : MonoBehaviour{};
```

该类继承自unity提供的`MonoBehavior`类，因此它会有一个名为`Update()`的函数用于游戏每帧调用。我找到了该函数并随其调用链逐层向下，发现了射弹创建相关的代码及其对应的另一个继承自MonoBehavior的类：`AttackLine`，鉴于其基类同样为`MonoBehavior`，它最终应该会被挂载于某个GameObject上，很可能是射弹之类的。

在主角执行攻击动作时，会在`AIAction.DoAttack()`中从pool里申请一个`AttackLine`对象，并调用`AttackLine.StartTrajectory()`对射弹的部分信息进行初始化。同时StartTrajectory函数在执行过程中将射弹被保存在游戏的Turns对象中，确保其在其该有的生命周期中一直存在，而AttackLine会在其存在时每帧调用它自己的`Update()`方法，从而不断进行当前子弹位置的计算并进行射线检测判断子弹是否击中对象，如果击中对象后对子弹进行销毁。

我在`AttackLine.Update()`和其调用的`AttackLine.DoUpdate()`中手动添加了一些“调试信息”，让其能够输出子弹的当前位置及朝向信息，以及函数的当前的执行位置。最后发现，激光枪在执行开火后，射弹确实在下一回合产生，并且此时产生的射弹初始位置坐标显然是一个错误值：(10000,0,0)，这证实了我的一部分猜想。那么接下来要搞明白的问题是，为什么子弹的初始位置没有正确地初始化？

再看一下`AttackLine.DoUpdate()`的总体结构：

```cs
public void DoUpdate()
{
    if (!GameBrain.boo.turns.turnPaused)
    {
    	if (!this.wpnSet)
        {
            // 进行值初始化并将wpnSet设为true
        }
        // 弹道计算
    }
	this.wpnSet = true;
}
```

不难看出它的意图：在AttackLine对象的Update第一次被调用时，它会将`AttackLine`的一个bool型成员变量`wpnSet`的值设为`true`，以表明该射弹的基础信息已完成初始化。直觉告诉我这可能和bug真正的原因有关系。因此我尝试在游戏运行时监控此值，发现当射弹位置出现(10000,0,0)错误的同时，`wpnSet == true`。而从这个变量被设置的意图来看，这显然是不对的。

答案已经很明确了。<span style="text-decoration:underline;">在第一回合执行结束后，游戏进入暂停状态，而此时AttackLine对象开始进行第一次自己的`DoUpdate()`方法调用。但注意，由于此时 `!GameBrain.boo.turns.turnPaused`的值为`false`，这次调用在未进行完基础信息初始化前就退出了。然而！由于`this.wpnSet = true;`的赋值语句存在于`if (!GameBrain.boo.turns.turnPaused)`之外，所以无论回合是否暂停，这条赋值语句必定执行。在之后的DoUpdate中，AttackLine对象以为它的射弹基础信息已被正确初始化了，于是开始以此基础计算弹道，但实际上它没有，所以它计算出了错误的子弹位置，子弹直接生成到爪哇国去了，当然是无法击中敌人的。</span>

于是我将DoUpdate的函数体改为如下形式：

```cs
public void DoUpdate()
{
    if (GameBrain.boo.turns.turnPaused)
	{
		return;
	}
    if (!this.wpnSet)
    {
        // 进行值初始化并将wpnSet设为true
    }
    // 弹道计算

    this.wpnSet = true;
}
```

再次进入游戏，发现激光枪的射弹可以在下一回合正确生成了！

不过其实还剩下最后一个问题萦绕在我心中：为什么等离子手枪和实弹手枪的子弹能在本回合生成，而激光枪却不行呢？这显然和武器数值设计存在某种关系，于是我在游戏里打开了背包并开始浏览所有枪支的武器信息，并在里面查找和回合有关的东西（我之前甚至从来没在游戏里看过它们的具体信息），最后我找到了一个武器属性：Attack Turns，激光、实弹和等离子武器的这项属性值分别为0、1、2。

这是一个很有意思的事，之前我一直以为激光要比其它武器的攻击时间长，但实际上它是最短的。这里面肯定有什么原因让它无比特殊地在下一个回合才生成射弹。在仔细浏览了Turns中的各个函数后，我发现我之前对这个游戏的“回合”的理解其实忽略了一个重要的细节。

<span style="text-decoration:underline;">游戏的“回合”概念在架构层面上其实并不是以玩家为中心的。当游戏每进行一次暂停让玩家选择操作时，其实中间已经过了很多个回合。每个回合的时长被一个计时器严格地监控和限制，而Turns对象每帧会检查当前玩家状态并做出对应的决策（如判断战斗结束等）。攻击准备（前摇）、攻击执行、和物品交互等动作其实都占用了单个或多个回合――具体回合数取决于当前玩家的属性、装备数值、动作类型等。而当玩家处于硬直状态，或action recovery turn中时游戏是不会进入暂停状态的，这让人产生了一种这个回合没有结束的错觉，而事实上此时可能已经有多个回合结束了。</span>

<span style="text-decoration:underline;">说回武器的Attack Turns属性：由于Grace为3且手持Attack Turn为0时，玩家的攻击动作和射弹生成会被认为真正地在同一个回合中执行，而当射弹开始执行第一个Update函数时，这个回合刚好结束，而又由于Grace为3时action recovery turns恰为0，这意味着玩家将立刻开始行动，因此游戏执行了暂停，让玩家进行操作。结果因为上面的代码逻辑错误，恰好导致了射弹初始化异常。</span>

至此，所有的问题都说得通了！